{"ast":null,"code":"import _objectSpread from \"/home/ysv/IdeaProjects/site/src/main/webapp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread\";\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nexport const getOnDemandLazySlides = spec => {\n  let onDemandSlides = [];\n  let startIndex = lazyStartIndex(spec);\n  let endIndex = lazyEndIndex(spec);\n\n  for (let slideIndex = startIndex; slideIndex < endIndex; slideIndex++) {\n    if (spec.lazyLoadedList.indexOf(slideIndex) < 0) {\n      onDemandSlides.push(slideIndex);\n    }\n  }\n\n  return onDemandSlides;\n}; // return list of slides that need to be present\n\nexport const getRequiredLazySlides = spec => {\n  let requiredSlides = [];\n  let startIndex = lazyStartIndex(spec);\n  let endIndex = lazyEndIndex(spec);\n\n  for (let slideIndex = startIndex; slideIndex < endIndex; slideIndex++) {\n    requiredSlides.push(slideIndex);\n  }\n\n  return requiredSlides;\n}; // startIndex that needs to be present\n\nexport const lazyStartIndex = spec => spec.currentSlide - lazySlidesOnLeft(spec);\nexport const lazyEndIndex = spec => spec.currentSlide + lazySlidesOnRight(spec);\nexport const lazySlidesOnLeft = spec => spec.centerMode ? Math.floor(spec.slidesToShow / 2) + (parseInt(spec.centerPadding) > 0 ? 1 : 0) : 0;\nexport const lazySlidesOnRight = spec => spec.centerMode ? Math.floor((spec.slidesToShow - 1) / 2) + 1 + (parseInt(spec.centerPadding) > 0 ? 1 : 0) : spec.slidesToShow; // get width of an element\n\nexport const getWidth = elem => elem && elem.offsetWidth || 0;\nexport const getHeight = elem => elem && elem.offsetHeight || 0;\nexport const getSwipeDirection = (touchObject, verticalSwiping = false) => {\n  var xDist, yDist, r, swipeAngle;\n  xDist = touchObject.startX - touchObject.curX;\n  yDist = touchObject.startY - touchObject.curY;\n  r = Math.atan2(yDist, xDist);\n  swipeAngle = Math.round(r * 180 / Math.PI);\n\n  if (swipeAngle < 0) {\n    swipeAngle = 360 - Math.abs(swipeAngle);\n  }\n\n  if (swipeAngle <= 45 && swipeAngle >= 0 || swipeAngle <= 360 && swipeAngle >= 315) {\n    return \"left\";\n  }\n\n  if (swipeAngle >= 135 && swipeAngle <= 225) {\n    return \"right\";\n  }\n\n  if (verticalSwiping === true) {\n    if (swipeAngle >= 35 && swipeAngle <= 135) {\n      return \"up\";\n    } else {\n      return \"down\";\n    }\n  }\n\n  return \"vertical\";\n}; // whether or not we can go next\n\nexport const canGoNext = spec => {\n  let canGo = true;\n\n  if (!spec.infinite) {\n    if (spec.centerMode && spec.currentSlide >= spec.slideCount - 1) {\n      canGo = false;\n    } else if (spec.slideCount <= spec.slidesToShow || spec.currentSlide >= spec.slideCount - spec.slidesToShow) {\n      canGo = false;\n    }\n  }\n\n  return canGo;\n}; // given an object and a list of keys, return new object with given keys\n\nexport const extractObject = (spec, keys) => {\n  let newObject = {};\n  keys.forEach(key => newObject[key] = spec[key]);\n  return newObject;\n}; // get initialized state\n\nexport const initializedState = spec => {\n  // spec also contains listRef, trackRef\n  let slideCount = React.Children.count(spec.children);\n  let listWidth = Math.ceil(getWidth(ReactDOM.findDOMNode(spec.listRef)));\n  let trackWidth = Math.ceil(getWidth(ReactDOM.findDOMNode(spec.trackRef)));\n  let slideWidth;\n\n  if (!spec.vertical) {\n    let centerPaddingAdj = spec.centerMode && parseInt(spec.centerPadding) * 2;\n\n    if (typeof spec.centerPadding === \"string\" && spec.centerPadding.slice(-1) === \"%\") {\n      centerPaddingAdj *= listWidth / 100;\n    }\n\n    slideWidth = Math.ceil((listWidth - centerPaddingAdj) / spec.slidesToShow);\n  } else {\n    slideWidth = listWidth;\n  }\n\n  let slideHeight = ReactDOM.findDOMNode(spec.listRef) && getHeight(ReactDOM.findDOMNode(spec.listRef).querySelector('[data-index=\"0\"]'));\n  let listHeight = slideHeight * spec.slidesToShow;\n  let currentSlide = spec.currentSlide === undefined ? spec.initialSlide : spec.currentSlide;\n\n  if (spec.rtl && spec.currentSlide === undefined) {\n    currentSlide = slideCount - 1 - spec.initialSlide;\n  }\n\n  let lazyLoadedList = spec.lazyLoadedList || [];\n  let slidesToLoad = getOnDemandLazySlides({\n    currentSlide,\n    lazyLoadedList\n  }, spec);\n  lazyLoadedList.concat(slidesToLoad);\n  let state = {\n    slideCount,\n    slideWidth,\n    listWidth,\n    trackWidth,\n    currentSlide,\n    slideHeight,\n    listHeight,\n    lazyLoadedList\n  };\n\n  if (spec.autoplaying === null && spec.autoplay) {\n    state[\"autoplaying\"] = \"playing\";\n  }\n\n  return state;\n};\nexport const slideHandler = spec => {\n  const waitForAnimate = spec.waitForAnimate,\n        animating = spec.animating,\n        fade = spec.fade,\n        infinite = spec.infinite,\n        index = spec.index,\n        slideCount = spec.slideCount,\n        lazyLoadedList = spec.lazyLoadedList,\n        lazyLoad = spec.lazyLoad,\n        currentSlide = spec.currentSlide,\n        centerMode = spec.centerMode,\n        slidesToScroll = spec.slidesToScroll,\n        slidesToShow = spec.slidesToShow,\n        useCSS = spec.useCSS;\n  if (waitForAnimate && animating) return {};\n  let animationSlide = index,\n      finalSlide,\n      animationLeft,\n      finalLeft;\n  let state = {},\n      nextState = {};\n\n  if (fade) {\n    if (!infinite && (index < 0 || index >= slideCount)) return {};\n\n    if (index < 0) {\n      animationSlide = index + slideCount;\n    } else if (index >= slideCount) {\n      animationSlide = index - slideCount;\n    }\n\n    if (lazyLoad && lazyLoadedList.indexOf(animationSlide) < 0) {\n      lazyLoadedList.push(animationSlide);\n    }\n\n    state = {\n      animating: true,\n      currentSlide: animationSlide,\n      lazyLoadedList\n    };\n    nextState = {\n      animating: false\n    };\n  } else {\n    finalSlide = animationSlide;\n\n    if (animationSlide < 0) {\n      finalSlide = animationSlide + slideCount;\n      if (!infinite) finalSlide = 0;else if (slideCount % slidesToScroll !== 0) finalSlide = slideCount - slideCount % slidesToScroll;\n    } else if (!canGoNext(spec) && animationSlide > currentSlide) {\n      animationSlide = finalSlide = currentSlide;\n    } else if (centerMode && animationSlide >= slideCount) {\n      animationSlide = infinite ? slideCount : slideCount - 1;\n      finalSlide = infinite ? 0 : slideCount - 1;\n    } else if (animationSlide >= slideCount) {\n      finalSlide = animationSlide - slideCount;\n      if (!infinite) finalSlide = slideCount - slidesToShow;else if (slideCount % slidesToScroll !== 0) finalSlide = 0;\n    }\n\n    animationLeft = getTrackLeft(_objectSpread({}, spec, {\n      slideIndex: animationSlide\n    }));\n    finalLeft = getTrackLeft(_objectSpread({}, spec, {\n      slideIndex: finalSlide\n    }));\n\n    if (!infinite) {\n      if (animationLeft === finalLeft) animationSlide = finalSlide;\n      animationLeft = finalLeft;\n    }\n\n    lazyLoad && lazyLoadedList.concat(getOnDemandLazySlides(_objectSpread({}, spec, {\n      currentSlide: animationSlide\n    })));\n\n    if (!useCSS) {\n      state = {\n        currentSlide: finalSlide,\n        trackStyle: getTrackCSS(_objectSpread({}, spec, {\n          left: finalLeft\n        })),\n        lazyLoadedList\n      };\n    } else {\n      state = {\n        animating: true,\n        currentSlide: finalSlide,\n        trackStyle: getTrackAnimateCSS(_objectSpread({}, spec, {\n          left: animationLeft\n        })),\n        lazyLoadedList\n      };\n      nextState = {\n        animating: false,\n        currentSlide: finalSlide,\n        trackStyle: getTrackCSS(_objectSpread({}, spec, {\n          left: finalLeft\n        })),\n        swipeLeft: null\n      };\n    }\n  }\n\n  return {\n    state,\n    nextState\n  };\n};\nexport const changeSlide = (spec, options) => {\n  var indexOffset, previousInt, slideOffset, unevenOffset, targetSlide;\n  const slidesToScroll = spec.slidesToScroll,\n        slidesToShow = spec.slidesToShow,\n        slideCount = spec.slideCount,\n        currentSlide = spec.currentSlide,\n        lazyLoad = spec.lazyLoad,\n        infinite = spec.infinite;\n  unevenOffset = slideCount % slidesToScroll !== 0;\n  indexOffset = unevenOffset ? 0 : (slideCount - currentSlide) % slidesToScroll;\n\n  if (options.message === \"previous\") {\n    slideOffset = indexOffset === 0 ? slidesToScroll : slidesToShow - indexOffset;\n    targetSlide = currentSlide - slideOffset;\n\n    if (lazyLoad && !infinite) {\n      previousInt = currentSlide - slideOffset;\n      targetSlide = previousInt === -1 ? slideCount - 1 : previousInt;\n    }\n  } else if (options.message === \"next\") {\n    slideOffset = indexOffset === 0 ? slidesToScroll : indexOffset;\n    targetSlide = currentSlide + slideOffset;\n\n    if (lazyLoad && !infinite) {\n      targetSlide = (currentSlide + slidesToScroll) % slideCount + indexOffset;\n    }\n  } else if (options.message === \"dots\") {\n    // Click on dots\n    targetSlide = options.index * options.slidesToScroll;\n\n    if (targetSlide === options.currentSlide) {\n      return null;\n    }\n  } else if (options.message === \"children\") {\n    // Click on the slides\n    targetSlide = options.index;\n\n    if (targetSlide === options.currentSlide) {\n      return null;\n    }\n\n    if (infinite) {\n      let direction = siblingDirection(_objectSpread({}, spec, {\n        targetSlide\n      }));\n\n      if (targetSlide > options.currentSlide && direction === \"left\") {\n        targetSlide = targetSlide - slideCount;\n      } else if (targetSlide < options.currentSlide && direction === \"right\") {\n        targetSlide = targetSlide + slideCount;\n      }\n    }\n  } else if (options.message === \"index\") {\n    targetSlide = Number(options.index);\n\n    if (targetSlide === options.currentSlide) {\n      return null;\n    }\n  }\n\n  return targetSlide;\n};\nexport const keyHandler = (e, accessibility, rtl) => {\n  if (e.target.tagName.match(\"TEXTAREA|INPUT|SELECT\") || !accessibility) return \"\";\n  if (e.keyCode === 37) return rtl ? \"next\" : \"previous\";\n  if (e.keyCode === 39) return rtl ? \"previous\" : \"next\";\n  return \"\";\n};\nexport const swipeStart = (e, swipe, draggable) => {\n  e.target.tagName === \"IMG\" && e.preventDefault();\n  if (!swipe || !draggable && e.type.indexOf(\"mouse\") !== -1) return \"\";\n  return {\n    dragging: true,\n    touchObject: {\n      startX: e.touches ? e.touches[0].pageX : e.clientX,\n      startY: e.touches ? e.touches[0].pageY : e.clientY,\n      curX: e.touches ? e.touches[0].pageX : e.clientX,\n      curY: e.touches ? e.touches[0].pageY : e.clientY\n    }\n  };\n};\nexport const swipeMove = (e, spec) => {\n  // spec also contains, trackRef and slideIndex\n  const scrolling = spec.scrolling,\n        animating = spec.animating,\n        vertical = spec.vertical,\n        swipeToSlide = spec.swipeToSlide,\n        verticalSwiping = spec.verticalSwiping,\n        rtl = spec.rtl,\n        currentSlide = spec.currentSlide,\n        edgeFriction = spec.edgeFriction,\n        edgeDragged = spec.edgeDragged,\n        onEdge = spec.onEdge,\n        swiped = spec.swiped,\n        swiping = spec.swiping,\n        slideCount = spec.slideCount,\n        slidesToScroll = spec.slidesToScroll,\n        infinite = spec.infinite,\n        touchObject = spec.touchObject,\n        swipeEvent = spec.swipeEvent,\n        listHeight = spec.listHeight,\n        listWidth = spec.listWidth;\n  if (scrolling) return;\n  if (animating) return e.preventDefault();\n  if (vertical && swipeToSlide && verticalSwiping) e.preventDefault();\n  let swipeLeft,\n      state = {};\n  let curLeft = getTrackLeft(spec);\n  touchObject.curX = e.touches ? e.touches[0].pageX : e.clientX;\n  touchObject.curY = e.touches ? e.touches[0].pageY : e.clientY;\n  touchObject.swipeLength = Math.round(Math.sqrt(Math.pow(touchObject.curX - touchObject.startX, 2)));\n  let verticalSwipeLength = Math.round(Math.sqrt(Math.pow(touchObject.curY - touchObject.startY, 2)));\n\n  if (!verticalSwiping && !swiping && verticalSwipeLength > 10) {\n    return {\n      scrolling: true\n    };\n  }\n\n  if (verticalSwiping) touchObject.swipeLength = verticalSwipeLength;\n  let positionOffset = (!rtl ? 1 : -1) * (touchObject.curX > touchObject.startX ? 1 : -1);\n  if (verticalSwiping) positionOffset = touchObject.curY > touchObject.startY ? 1 : -1;\n  let dotCount = Math.ceil(slideCount / slidesToScroll);\n  let swipeDirection = getSwipeDirection(spec.touchObject, verticalSwiping);\n  let touchSwipeLength = touchObject.swipeLength;\n\n  if (!infinite) {\n    if (currentSlide === 0 && swipeDirection === \"right\" || currentSlide + 1 >= dotCount && swipeDirection === \"left\" || !canGoNext(spec) && swipeDirection === \"left\") {\n      touchSwipeLength = touchObject.swipeLength * edgeFriction;\n\n      if (edgeDragged === false && onEdge) {\n        onEdge(swipeDirection);\n        state[\"edgeDragged\"] = true;\n      }\n    }\n  }\n\n  if (!swiped && swipeEvent) {\n    swipeEvent(swipeDirection);\n    state[\"swiped\"] = true;\n  }\n\n  if (!vertical) {\n    if (!rtl) {\n      swipeLeft = curLeft + touchSwipeLength * positionOffset;\n    } else {\n      swipeLeft = curLeft - touchSwipeLength * positionOffset;\n    }\n  } else {\n    swipeLeft = curLeft + touchSwipeLength * (listHeight / listWidth) * positionOffset;\n  }\n\n  if (verticalSwiping) {\n    swipeLeft = curLeft + touchSwipeLength * positionOffset;\n  }\n\n  state = _objectSpread({}, state, {\n    touchObject,\n    swipeLeft,\n    trackStyle: getTrackCSS(_objectSpread({}, spec, {\n      left: swipeLeft\n    }))\n  });\n\n  if (Math.abs(touchObject.curX - touchObject.startX) < Math.abs(touchObject.curY - touchObject.startY) * 0.8) {\n    return state;\n  }\n\n  if (touchObject.swipeLength > 10) {\n    state[\"swiping\"] = true;\n    e.preventDefault();\n  }\n\n  return state;\n};\nexport const swipeEnd = (e, spec) => {\n  const dragging = spec.dragging,\n        swipe = spec.swipe,\n        touchObject = spec.touchObject,\n        listWidth = spec.listWidth,\n        touchThreshold = spec.touchThreshold,\n        verticalSwiping = spec.verticalSwiping,\n        listHeight = spec.listHeight,\n        currentSlide = spec.currentSlide,\n        swipeToSlide = spec.swipeToSlide,\n        scrolling = spec.scrolling,\n        onSwipe = spec.onSwipe;\n\n  if (!dragging) {\n    if (swipe) e.preventDefault();\n    return {};\n  }\n\n  let minSwipe = verticalSwiping ? listHeight / touchThreshold : listWidth / touchThreshold;\n  let swipeDirection = getSwipeDirection(touchObject, verticalSwiping); // reset the state of touch related state variables.\n\n  let state = {\n    dragging: false,\n    edgeDragged: false,\n    scrolling: false,\n    swiping: false,\n    swiped: false,\n    swipeLeft: null,\n    touchObject: {}\n  };\n\n  if (scrolling) {\n    return state;\n  }\n\n  if (!touchObject.swipeLength) {\n    return state;\n  }\n\n  if (touchObject.swipeLength > minSwipe) {\n    e.preventDefault();\n\n    if (onSwipe) {\n      onSwipe(swipeDirection);\n    }\n\n    let slideCount, newSlide;\n\n    switch (swipeDirection) {\n      case \"left\":\n      case \"up\":\n        newSlide = currentSlide + getSlideCount(spec);\n        slideCount = swipeToSlide ? checkNavigable(spec, newSlide) : newSlide;\n        state[\"currentDirection\"] = 0;\n        break;\n\n      case \"right\":\n      case \"down\":\n        newSlide = currentSlide - getSlideCount(spec);\n        slideCount = swipeToSlide ? checkNavigable(spec, newSlide) : newSlide;\n        state[\"currentDirection\"] = 1;\n        break;\n\n      default:\n        slideCount = currentSlide;\n    }\n\n    state[\"triggerSlideHandler\"] = slideCount;\n  } else {\n    // Adjust the track back to it's original position.\n    let currentLeft = getTrackLeft(spec);\n    state[\"trackStyle\"] = getTrackAnimateCSS(_objectSpread({}, spec, {\n      left: currentLeft\n    }));\n  }\n\n  return state;\n};\nexport const getNavigableIndexes = spec => {\n  let max = spec.infinite ? spec.slideCount * 2 : spec.slideCount;\n  let breakpoint = spec.infinite ? spec.slidesToShow * -1 : 0;\n  let counter = spec.infinite ? spec.slidesToShow * -1 : 0;\n  let indexes = [];\n\n  while (breakpoint < max) {\n    indexes.push(breakpoint);\n    breakpoint = counter + spec.slidesToScroll;\n    counter += Math.min(spec.slidesToScroll, spec.slidesToShow);\n  }\n\n  return indexes;\n};\nexport const checkNavigable = (spec, index) => {\n  const navigables = getNavigableIndexes(spec);\n  let prevNavigable = 0;\n\n  if (index > navigables[navigables.length - 1]) {\n    index = navigables[navigables.length - 1];\n  } else {\n    for (let n in navigables) {\n      if (index < navigables[n]) {\n        index = prevNavigable;\n        break;\n      }\n\n      prevNavigable = navigables[n];\n    }\n  }\n\n  return index;\n};\nexport const getSlideCount = spec => {\n  const centerOffset = spec.centerMode ? spec.slideWidth * Math.floor(spec.slidesToShow / 2) : 0;\n\n  if (spec.swipeToSlide) {\n    let swipedSlide;\n    const slickList = ReactDOM.findDOMNode(spec.listRef);\n    const slides = slickList.querySelectorAll(\".slick-slide\");\n    Array.from(slides).every(slide => {\n      if (!spec.vertical) {\n        if (slide.offsetLeft - centerOffset + getWidth(slide) / 2 > spec.swipeLeft * -1) {\n          swipedSlide = slide;\n          return false;\n        }\n      } else {\n        if (slide.offsetTop + getHeight(slide) / 2 > spec.swipeLeft * -1) {\n          swipedSlide = slide;\n          return false;\n        }\n      }\n\n      return true;\n    });\n\n    if (!swipedSlide) {\n      return 0;\n    }\n\n    const currentIndex = spec.rtl === true ? spec.slideCount - spec.currentSlide : spec.currentSlide;\n    const slidesTraversed = Math.abs(swipedSlide.dataset.index - currentIndex) || 1;\n    return slidesTraversed;\n  } else {\n    return spec.slidesToScroll;\n  }\n};\nexport const checkSpecKeys = (spec, keysArray) => keysArray.reduce((value, key) => value && spec.hasOwnProperty(key), true) ? null : console.error(\"Keys Missing:\", spec);\nexport const getTrackCSS = spec => {\n  checkSpecKeys(spec, [\"left\", \"variableWidth\", \"slideCount\", \"slidesToShow\", \"slideWidth\"]);\n  let trackWidth, trackHeight;\n  const trackChildren = spec.slideCount + 2 * spec.slidesToShow;\n\n  if (!spec.vertical) {\n    trackWidth = getTotalSlides(spec) * spec.slideWidth;\n  } else {\n    trackHeight = trackChildren * spec.slideHeight;\n  }\n\n  let style = {\n    opacity: 1,\n    transition: \"\",\n    WebkitTransition: \"\"\n  };\n\n  if (spec.useTransform) {\n    let WebkitTransform = !spec.vertical ? \"translate3d(\" + spec.left + \"px, 0px, 0px)\" : \"translate3d(0px, \" + spec.left + \"px, 0px)\";\n    let transform = !spec.vertical ? \"translate3d(\" + spec.left + \"px, 0px, 0px)\" : \"translate3d(0px, \" + spec.left + \"px, 0px)\";\n    let msTransform = !spec.vertical ? \"translateX(\" + spec.left + \"px)\" : \"translateY(\" + spec.left + \"px)\";\n    style = _objectSpread({}, style, {\n      WebkitTransform,\n      transform,\n      msTransform\n    });\n  } else {\n    if (spec.vertical) {\n      style[\"top\"] = spec.left;\n    } else {\n      style[\"left\"] = spec.left;\n    }\n  }\n\n  if (spec.fade) style = {\n    opacity: 1\n  };\n  if (trackWidth) style.width = trackWidth;\n  if (trackHeight) style.height = trackHeight; // Fallback for IE8\n\n  if (window && !window.addEventListener && window.attachEvent) {\n    if (!spec.vertical) {\n      style.marginLeft = spec.left + \"px\";\n    } else {\n      style.marginTop = spec.left + \"px\";\n    }\n  }\n\n  return style;\n};\nexport const getTrackAnimateCSS = spec => {\n  checkSpecKeys(spec, [\"left\", \"variableWidth\", \"slideCount\", \"slidesToShow\", \"slideWidth\", \"speed\", \"cssEase\"]);\n  let style = getTrackCSS(spec); // useCSS is true by default so it can be undefined\n\n  if (spec.useTransform) {\n    style.WebkitTransition = \"-webkit-transform \" + spec.speed + \"ms \" + spec.cssEase;\n    style.transition = \"transform \" + spec.speed + \"ms \" + spec.cssEase;\n  } else {\n    if (spec.vertical) {\n      style.transition = \"top \" + spec.speed + \"ms \" + spec.cssEase;\n    } else {\n      style.transition = \"left \" + spec.speed + \"ms \" + spec.cssEase;\n    }\n  }\n\n  return style;\n};\nexport const getTrackLeft = spec => {\n  if (spec.unslick) {\n    return 0;\n  }\n\n  checkSpecKeys(spec, [\"slideIndex\", \"trackRef\", \"infinite\", \"centerMode\", \"slideCount\", \"slidesToShow\", \"slidesToScroll\", \"slideWidth\", \"listWidth\", \"variableWidth\", \"slideHeight\"]);\n  const slideIndex = spec.slideIndex,\n        trackRef = spec.trackRef,\n        infinite = spec.infinite,\n        centerMode = spec.centerMode,\n        slideCount = spec.slideCount,\n        slidesToShow = spec.slidesToShow,\n        slidesToScroll = spec.slidesToScroll,\n        slideWidth = spec.slideWidth,\n        listWidth = spec.listWidth,\n        variableWidth = spec.variableWidth,\n        slideHeight = spec.slideHeight,\n        fade = spec.fade,\n        vertical = spec.vertical;\n  var slideOffset = 0;\n  var targetLeft;\n  var targetSlide;\n  var verticalOffset = 0;\n\n  if (fade || spec.slideCount === 1) {\n    return 0;\n  }\n\n  let slidesToOffset = 0;\n\n  if (infinite) {\n    slidesToOffset = -getPreClones(spec); // bring active slide to the beginning of visual area\n    // if next scroll doesn't have enough children, just reach till the end of original slides instead of shifting slidesToScroll children\n\n    if (slideCount % slidesToScroll !== 0 && slideIndex + slidesToScroll > slideCount) {\n      slidesToOffset = -(slideIndex > slideCount ? slidesToShow - (slideIndex - slideCount) : slideCount % slidesToScroll);\n    } // shift current slide to center of the frame\n\n\n    if (centerMode) {\n      slidesToOffset += parseInt(slidesToShow / 2);\n    }\n  } else {\n    if (slideCount % slidesToScroll !== 0 && slideIndex + slidesToScroll > slideCount) {\n      slidesToOffset = slidesToShow - slideCount % slidesToScroll;\n    }\n\n    if (centerMode) {\n      slidesToOffset = parseInt(slidesToShow / 2);\n    }\n  }\n\n  slideOffset = slidesToOffset * slideWidth;\n  verticalOffset = slidesToOffset * slideHeight;\n\n  if (!vertical) {\n    targetLeft = slideIndex * slideWidth * -1 + slideOffset;\n  } else {\n    targetLeft = slideIndex * slideHeight * -1 + verticalOffset;\n  }\n\n  if (variableWidth === true) {\n    var targetSlideIndex;\n    let trackElem = ReactDOM.findDOMNode(trackRef);\n    targetSlideIndex = slideIndex + getPreClones(spec);\n    targetSlide = trackElem && trackElem.childNodes[targetSlideIndex];\n    targetLeft = targetSlide ? targetSlide.offsetLeft * -1 : 0;\n\n    if (centerMode === true) {\n      targetSlideIndex = infinite ? slideIndex + getPreClones(spec) : slideIndex;\n      targetSlide = trackElem && trackElem.children[targetSlideIndex];\n      targetLeft = 0;\n\n      for (let slide = 0; slide < targetSlideIndex; slide++) {\n        targetLeft -= trackElem && trackElem.children[slide] && trackElem.children[slide].offsetWidth;\n      }\n\n      targetLeft -= parseInt(spec.centerPadding);\n      targetLeft += targetSlide && (listWidth - targetSlide.offsetWidth) / 2;\n    }\n  }\n\n  return targetLeft;\n};\nexport const getPreClones = spec => {\n  if (spec.unslick || !spec.infinite) {\n    return 0;\n  }\n\n  if (spec.variableWidth) {\n    return spec.slideCount;\n  }\n\n  return spec.slidesToShow + (spec.centerMode ? 1 : 0);\n};\nexport const getPostClones = spec => {\n  if (spec.unslick || !spec.infinite) {\n    return 0;\n  }\n\n  return spec.slideCount;\n};\nexport const getTotalSlides = spec => spec.slideCount === 1 ? 1 : getPreClones(spec) + spec.slideCount + getPostClones(spec);\nexport const siblingDirection = spec => {\n  if (spec.targetSlide > spec.currentSlide) {\n    if (spec.targetSlide > spec.currentSlide + slidesOnRight(spec)) {\n      return \"left\";\n    }\n\n    return \"right\";\n  } else {\n    if (spec.targetSlide < spec.currentSlide - slidesOnLeft(spec)) {\n      return \"right\";\n    }\n\n    return \"left\";\n  }\n};\nexport const slidesOnRight = ({\n  slidesToShow,\n  centerMode,\n  rtl,\n  centerPadding\n}) => {\n  // returns no of slides on the right of active slide\n  if (centerMode) {\n    let right = (slidesToShow - 1) / 2 + 1;\n    if (parseInt(centerPadding) > 0) right += 1;\n    if (rtl && slidesToShow % 2 === 0) right += 1;\n    return right;\n  }\n\n  if (rtl) {\n    return 0;\n  }\n\n  return slidesToShow - 1;\n};\nexport const slidesOnLeft = ({\n  slidesToShow,\n  centerMode,\n  rtl,\n  centerPadding\n}) => {\n  // returns no of slides on the left of active slide\n  if (centerMode) {\n    let left = (slidesToShow - 1) / 2 + 1;\n    if (parseInt(centerPadding) > 0) left += 1;\n    if (!rtl && slidesToShow % 2 === 0) left += 1;\n    return left;\n  }\n\n  if (rtl) {\n    return slidesToShow - 1;\n  }\n\n  return 0;\n};\nexport const canUseDOM = () => !!(typeof window !== \"undefined\" && window.document && window.document.createElement);","map":{"version":3,"sources":["/home/ysv/IdeaProjects/site/src/main/webapp/src/slick/utils/innerSliderUtils.js"],"names":["React","ReactDOM","getOnDemandLazySlides","spec","onDemandSlides","startIndex","lazyStartIndex","endIndex","lazyEndIndex","slideIndex","lazyLoadedList","indexOf","push","getRequiredLazySlides","requiredSlides","currentSlide","lazySlidesOnLeft","lazySlidesOnRight","centerMode","Math","floor","slidesToShow","parseInt","centerPadding","getWidth","elem","offsetWidth","getHeight","offsetHeight","getSwipeDirection","touchObject","verticalSwiping","xDist","yDist","r","swipeAngle","startX","curX","startY","curY","atan2","round","PI","abs","canGoNext","canGo","infinite","slideCount","extractObject","keys","newObject","forEach","key","initializedState","Children","count","children","listWidth","ceil","findDOMNode","listRef","trackWidth","trackRef","slideWidth","vertical","centerPaddingAdj","slice","slideHeight","querySelector","listHeight","undefined","initialSlide","rtl","slidesToLoad","concat","state","autoplaying","autoplay","slideHandler","waitForAnimate","animating","fade","index","lazyLoad","slidesToScroll","useCSS","animationSlide","finalSlide","animationLeft","finalLeft","nextState","getTrackLeft","trackStyle","getTrackCSS","left","getTrackAnimateCSS","swipeLeft","changeSlide","options","indexOffset","previousInt","slideOffset","unevenOffset","targetSlide","message","direction","siblingDirection","Number","keyHandler","e","accessibility","target","tagName","match","keyCode","swipeStart","swipe","draggable","preventDefault","type","dragging","touches","pageX","clientX","pageY","clientY","swipeMove","scrolling","swipeToSlide","edgeFriction","edgeDragged","onEdge","swiped","swiping","swipeEvent","curLeft","swipeLength","sqrt","pow","verticalSwipeLength","positionOffset","dotCount","swipeDirection","touchSwipeLength","swipeEnd","touchThreshold","onSwipe","minSwipe","newSlide","getSlideCount","checkNavigable","currentLeft","getNavigableIndexes","max","breakpoint","counter","indexes","min","navigables","prevNavigable","length","n","centerOffset","swipedSlide","slickList","slides","querySelectorAll","Array","from","every","slide","offsetLeft","offsetTop","currentIndex","slidesTraversed","dataset","checkSpecKeys","keysArray","reduce","value","hasOwnProperty","console","error","trackHeight","trackChildren","getTotalSlides","style","opacity","transition","WebkitTransition","useTransform","WebkitTransform","transform","msTransform","width","height","window","addEventListener","attachEvent","marginLeft","marginTop","speed","cssEase","unslick","variableWidth","targetLeft","verticalOffset","slidesToOffset","getPreClones","targetSlideIndex","trackElem","childNodes","getPostClones","slidesOnRight","slidesOnLeft","right","canUseDOM","document","createElement"],"mappings":"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","sourcesContent":["import React from \"react\";\nimport ReactDOM from \"react-dom\";\n\nexport const getOnDemandLazySlides = spec => {\n  let onDemandSlides = [];\n  let startIndex = lazyStartIndex(spec);\n  let endIndex = lazyEndIndex(spec);\n  for (let slideIndex = startIndex; slideIndex < endIndex; slideIndex++) {\n    if (spec.lazyLoadedList.indexOf(slideIndex) < 0) {\n      onDemandSlides.push(slideIndex);\n    }\n  }\n  return onDemandSlides;\n};\n\n// return list of slides that need to be present\nexport const getRequiredLazySlides = spec => {\n  let requiredSlides = [];\n  let startIndex = lazyStartIndex(spec);\n  let endIndex = lazyEndIndex(spec);\n  for (let slideIndex = startIndex; slideIndex < endIndex; slideIndex++) {\n    requiredSlides.push(slideIndex);\n  }\n  return requiredSlides;\n};\n\n// startIndex that needs to be present\nexport const lazyStartIndex = spec =>\n  spec.currentSlide - lazySlidesOnLeft(spec);\nexport const lazyEndIndex = spec => spec.currentSlide + lazySlidesOnRight(spec);\nexport const lazySlidesOnLeft = spec =>\n  spec.centerMode\n    ? Math.floor(spec.slidesToShow / 2) +\n      (parseInt(spec.centerPadding) > 0 ? 1 : 0)\n    : 0;\nexport const lazySlidesOnRight = spec =>\n  spec.centerMode\n    ? Math.floor((spec.slidesToShow - 1) / 2) +\n      1 +\n      (parseInt(spec.centerPadding) > 0 ? 1 : 0)\n    : spec.slidesToShow;\n\n// get width of an element\nexport const getWidth = elem => (elem && elem.offsetWidth) || 0;\nexport const getHeight = elem => (elem && elem.offsetHeight) || 0;\nexport const getSwipeDirection = (touchObject, verticalSwiping = false) => {\n  var xDist, yDist, r, swipeAngle;\n  xDist = touchObject.startX - touchObject.curX;\n  yDist = touchObject.startY - touchObject.curY;\n  r = Math.atan2(yDist, xDist);\n  swipeAngle = Math.round(r * 180 / Math.PI);\n  if (swipeAngle < 0) {\n    swipeAngle = 360 - Math.abs(swipeAngle);\n  }\n  if (\n    (swipeAngle <= 45 && swipeAngle >= 0) ||\n    (swipeAngle <= 360 && swipeAngle >= 315)\n  ) {\n    return \"left\";\n  }\n  if (swipeAngle >= 135 && swipeAngle <= 225) {\n    return \"right\";\n  }\n  if (verticalSwiping === true) {\n    if (swipeAngle >= 35 && swipeAngle <= 135) {\n      return \"up\";\n    } else {\n      return \"down\";\n    }\n  }\n\n  return \"vertical\";\n};\n\n// whether or not we can go next\nexport const canGoNext = spec => {\n  let canGo = true;\n  if (!spec.infinite) {\n    if (spec.centerMode && spec.currentSlide >= spec.slideCount - 1) {\n      canGo = false;\n    } else if (\n      spec.slideCount <= spec.slidesToShow ||\n      spec.currentSlide >= spec.slideCount - spec.slidesToShow\n    ) {\n      canGo = false;\n    }\n  }\n  return canGo;\n};\n\n// given an object and a list of keys, return new object with given keys\nexport const extractObject = (spec, keys) => {\n  let newObject = {};\n  keys.forEach(key => (newObject[key] = spec[key]));\n  return newObject;\n};\n\n// get initialized state\nexport const initializedState = spec => {\n  // spec also contains listRef, trackRef\n  let slideCount = React.Children.count(spec.children);\n  let listWidth = Math.ceil(getWidth(ReactDOM.findDOMNode(spec.listRef)));\n  let trackWidth = Math.ceil(getWidth(ReactDOM.findDOMNode(spec.trackRef)));\n  let slideWidth;\n  if (!spec.vertical) {\n    let centerPaddingAdj = spec.centerMode && parseInt(spec.centerPadding) * 2;\n    if (\n      typeof spec.centerPadding === \"string\" &&\n      spec.centerPadding.slice(-1) === \"%\"\n    ) {\n      centerPaddingAdj *= listWidth / 100;\n    }\n    slideWidth = Math.ceil((listWidth - centerPaddingAdj) / spec.slidesToShow);\n  } else {\n    slideWidth = listWidth;\n  }\n  let slideHeight =\n    ReactDOM.findDOMNode(spec.listRef) &&\n    getHeight(\n      ReactDOM.findDOMNode(spec.listRef).querySelector('[data-index=\"0\"]')\n    );\n  let listHeight = slideHeight * spec.slidesToShow;\n  let currentSlide =\n    spec.currentSlide === undefined ? spec.initialSlide : spec.currentSlide;\n  if (spec.rtl && spec.currentSlide === undefined) {\n    currentSlide = slideCount - 1 - spec.initialSlide;\n  }\n  let lazyLoadedList = spec.lazyLoadedList || [];\n  let slidesToLoad = getOnDemandLazySlides(\n    { currentSlide, lazyLoadedList },\n    spec\n  );\n  lazyLoadedList.concat(slidesToLoad);\n\n  let state = {\n    slideCount,\n    slideWidth,\n    listWidth,\n    trackWidth,\n    currentSlide,\n    slideHeight,\n    listHeight,\n    lazyLoadedList\n  };\n\n  if (spec.autoplaying === null && spec.autoplay) {\n    state[\"autoplaying\"] = \"playing\";\n  }\n\n  return state;\n};\n\nexport const slideHandler = spec => {\n  const {\n    waitForAnimate,\n    animating,\n    fade,\n    infinite,\n    index,\n    slideCount,\n    lazyLoadedList,\n    lazyLoad,\n    currentSlide,\n    centerMode,\n    slidesToScroll,\n    slidesToShow,\n    useCSS\n  } = spec;\n  if (waitForAnimate && animating) return {};\n  let animationSlide = index,\n    finalSlide,\n    animationLeft,\n    finalLeft;\n  let state = {},\n    nextState = {};\n  if (fade) {\n    if (!infinite && (index < 0 || index >= slideCount)) return {};\n    if (index < 0) {\n      animationSlide = index + slideCount;\n    } else if (index >= slideCount) {\n      animationSlide = index - slideCount;\n    }\n    if (lazyLoad && lazyLoadedList.indexOf(animationSlide) < 0) {\n      lazyLoadedList.push(animationSlide);\n    }\n    state = {\n      animating: true,\n      currentSlide: animationSlide,\n      lazyLoadedList\n    };\n    nextState = { animating: false };\n  } else {\n    finalSlide = animationSlide;\n    if (animationSlide < 0) {\n      finalSlide = animationSlide + slideCount;\n      if (!infinite) finalSlide = 0;\n      else if (slideCount % slidesToScroll !== 0)\n        finalSlide = slideCount - slideCount % slidesToScroll;\n    } else if (!canGoNext(spec) && animationSlide > currentSlide) {\n      animationSlide = finalSlide = currentSlide;\n    } else if (centerMode && animationSlide >= slideCount) {\n      animationSlide = infinite ? slideCount : slideCount - 1;\n      finalSlide = infinite ? 0 : slideCount - 1;\n    } else if (animationSlide >= slideCount) {\n      finalSlide = animationSlide - slideCount;\n      if (!infinite) finalSlide = slideCount - slidesToShow;\n      else if (slideCount % slidesToScroll !== 0) finalSlide = 0;\n    }\n    animationLeft = getTrackLeft({ ...spec, slideIndex: animationSlide });\n    finalLeft = getTrackLeft({ ...spec, slideIndex: finalSlide });\n    if (!infinite) {\n      if (animationLeft === finalLeft) animationSlide = finalSlide;\n      animationLeft = finalLeft;\n    }\n    lazyLoad &&\n      lazyLoadedList.concat(\n        getOnDemandLazySlides({ ...spec, currentSlide: animationSlide })\n      );\n    if (!useCSS) {\n      state = {\n        currentSlide: finalSlide,\n        trackStyle: getTrackCSS({ ...spec, left: finalLeft }),\n        lazyLoadedList\n      };\n    } else {\n      state = {\n        animating: true,\n        currentSlide: finalSlide,\n        trackStyle: getTrackAnimateCSS({ ...spec, left: animationLeft }),\n        lazyLoadedList\n      };\n      nextState = {\n        animating: false,\n        currentSlide: finalSlide,\n        trackStyle: getTrackCSS({ ...spec, left: finalLeft }),\n        swipeLeft: null\n      };\n    }\n  }\n  return { state, nextState };\n};\n\nexport const changeSlide = (spec, options) => {\n  var indexOffset, previousInt, slideOffset, unevenOffset, targetSlide;\n  const {\n    slidesToScroll,\n    slidesToShow,\n    slideCount,\n    currentSlide,\n    lazyLoad,\n    infinite\n  } = spec;\n  unevenOffset = slideCount % slidesToScroll !== 0;\n  indexOffset = unevenOffset ? 0 : (slideCount - currentSlide) % slidesToScroll;\n\n  if (options.message === \"previous\") {\n    slideOffset =\n      indexOffset === 0 ? slidesToScroll : slidesToShow - indexOffset;\n    targetSlide = currentSlide - slideOffset;\n    if (lazyLoad && !infinite) {\n      previousInt = currentSlide - slideOffset;\n      targetSlide = previousInt === -1 ? slideCount - 1 : previousInt;\n    }\n  } else if (options.message === \"next\") {\n    slideOffset = indexOffset === 0 ? slidesToScroll : indexOffset;\n    targetSlide = currentSlide + slideOffset;\n    if (lazyLoad && !infinite) {\n      targetSlide = (currentSlide + slidesToScroll) % slideCount + indexOffset;\n    }\n  } else if (options.message === \"dots\") {\n    // Click on dots\n    targetSlide = options.index * options.slidesToScroll;\n    if (targetSlide === options.currentSlide) {\n      return null;\n    }\n  } else if (options.message === \"children\") {\n    // Click on the slides\n    targetSlide = options.index;\n    if (targetSlide === options.currentSlide) {\n      return null;\n    }\n    if (infinite) {\n      let direction = siblingDirection({ ...spec, targetSlide });\n      if (targetSlide > options.currentSlide && direction === \"left\") {\n        targetSlide = targetSlide - slideCount;\n      } else if (targetSlide < options.currentSlide && direction === \"right\") {\n        targetSlide = targetSlide + slideCount;\n      }\n    }\n  } else if (options.message === \"index\") {\n    targetSlide = Number(options.index);\n    if (targetSlide === options.currentSlide) {\n      return null;\n    }\n  }\n  return targetSlide;\n};\nexport const keyHandler = (e, accessibility, rtl) => {\n  if (e.target.tagName.match(\"TEXTAREA|INPUT|SELECT\") || !accessibility)\n    return \"\";\n  if (e.keyCode === 37) return rtl ? \"next\" : \"previous\";\n  if (e.keyCode === 39) return rtl ? \"previous\" : \"next\";\n  return \"\";\n};\n\nexport const swipeStart = (e, swipe, draggable) => {\n  e.target.tagName === \"IMG\" && e.preventDefault();\n  if (!swipe || (!draggable && e.type.indexOf(\"mouse\") !== -1)) return \"\";\n  return {\n    dragging: true,\n    touchObject: {\n      startX: e.touches ? e.touches[0].pageX : e.clientX,\n      startY: e.touches ? e.touches[0].pageY : e.clientY,\n      curX: e.touches ? e.touches[0].pageX : e.clientX,\n      curY: e.touches ? e.touches[0].pageY : e.clientY\n    }\n  };\n};\nexport const swipeMove = (e, spec) => {\n  // spec also contains, trackRef and slideIndex\n  const {\n    scrolling,\n    animating,\n    vertical,\n    swipeToSlide,\n    verticalSwiping,\n    rtl,\n    currentSlide,\n    edgeFriction,\n    edgeDragged,\n    onEdge,\n    swiped,\n    swiping,\n    slideCount,\n    slidesToScroll,\n    infinite,\n    touchObject,\n    swipeEvent,\n    listHeight,\n    listWidth\n  } = spec;\n  if (scrolling) return;\n  if (animating) return e.preventDefault();\n  if (vertical && swipeToSlide && verticalSwiping) e.preventDefault();\n  let swipeLeft,\n    state = {};\n  let curLeft = getTrackLeft(spec);\n  touchObject.curX = e.touches ? e.touches[0].pageX : e.clientX;\n  touchObject.curY = e.touches ? e.touches[0].pageY : e.clientY;\n  touchObject.swipeLength = Math.round(\n    Math.sqrt(Math.pow(touchObject.curX - touchObject.startX, 2))\n  );\n  let verticalSwipeLength = Math.round(\n    Math.sqrt(Math.pow(touchObject.curY - touchObject.startY, 2))\n  );\n  if (!verticalSwiping && !swiping && verticalSwipeLength > 10) {\n    return { scrolling: true };\n  }\n  if (verticalSwiping) touchObject.swipeLength = verticalSwipeLength;\n  let positionOffset =\n    (!rtl ? 1 : -1) * (touchObject.curX > touchObject.startX ? 1 : -1);\n  if (verticalSwiping)\n    positionOffset = touchObject.curY > touchObject.startY ? 1 : -1;\n\n  let dotCount = Math.ceil(slideCount / slidesToScroll);\n  let swipeDirection = getSwipeDirection(spec.touchObject, verticalSwiping);\n  let touchSwipeLength = touchObject.swipeLength;\n  if (!infinite) {\n    if (\n      (currentSlide === 0 && swipeDirection === \"right\") ||\n      (currentSlide + 1 >= dotCount && swipeDirection === \"left\") ||\n      (!canGoNext(spec) && swipeDirection === \"left\")\n    ) {\n      touchSwipeLength = touchObject.swipeLength * edgeFriction;\n      if (edgeDragged === false && onEdge) {\n        onEdge(swipeDirection);\n        state[\"edgeDragged\"] = true;\n      }\n    }\n  }\n  if (!swiped && swipeEvent) {\n    swipeEvent(swipeDirection);\n    state[\"swiped\"] = true;\n  }\n  if (!vertical) {\n    if (!rtl) {\n      swipeLeft = curLeft + touchSwipeLength * positionOffset;\n    } else {\n      swipeLeft = curLeft - touchSwipeLength * positionOffset;\n    }\n  } else {\n    swipeLeft =\n      curLeft + touchSwipeLength * (listHeight / listWidth) * positionOffset;\n  }\n  if (verticalSwiping) {\n    swipeLeft = curLeft + touchSwipeLength * positionOffset;\n  }\n  state = {\n    ...state,\n    touchObject,\n    swipeLeft,\n    trackStyle: getTrackCSS({ ...spec, left: swipeLeft })\n  };\n  if (\n    Math.abs(touchObject.curX - touchObject.startX) <\n    Math.abs(touchObject.curY - touchObject.startY) * 0.8\n  ) {\n    return state;\n  }\n  if (touchObject.swipeLength > 10) {\n    state[\"swiping\"] = true;\n    e.preventDefault();\n  }\n  return state;\n};\nexport const swipeEnd = (e, spec) => {\n  const {\n    dragging,\n    swipe,\n    touchObject,\n    listWidth,\n    touchThreshold,\n    verticalSwiping,\n    listHeight,\n    currentSlide,\n    swipeToSlide,\n    scrolling,\n    onSwipe\n  } = spec;\n  if (!dragging) {\n    if (swipe) e.preventDefault();\n    return {};\n  }\n  let minSwipe = verticalSwiping\n    ? listHeight / touchThreshold\n    : listWidth / touchThreshold;\n  let swipeDirection = getSwipeDirection(touchObject, verticalSwiping);\n  // reset the state of touch related state variables.\n  let state = {\n    dragging: false,\n    edgeDragged: false,\n    scrolling: false,\n    swiping: false,\n    swiped: false,\n    swipeLeft: null,\n    touchObject: {}\n  };\n  if (scrolling) {\n    return state;\n  }\n  if (!touchObject.swipeLength) {\n    return state;\n  }\n  if (touchObject.swipeLength > minSwipe) {\n    e.preventDefault();\n    if (onSwipe) {\n      onSwipe(swipeDirection);\n    }\n    let slideCount, newSlide;\n    switch (swipeDirection) {\n      case \"left\":\n      case \"up\":\n        newSlide = currentSlide + getSlideCount(spec);\n        slideCount = swipeToSlide ? checkNavigable(spec, newSlide) : newSlide;\n        state[\"currentDirection\"] = 0;\n        break;\n      case \"right\":\n      case \"down\":\n        newSlide = currentSlide - getSlideCount(spec);\n        slideCount = swipeToSlide ? checkNavigable(spec, newSlide) : newSlide;\n        state[\"currentDirection\"] = 1;\n        break;\n      default:\n        slideCount = currentSlide;\n    }\n    state[\"triggerSlideHandler\"] = slideCount;\n  } else {\n    // Adjust the track back to it's original position.\n    let currentLeft = getTrackLeft(spec);\n    state[\"trackStyle\"] = getTrackAnimateCSS({ ...spec, left: currentLeft });\n  }\n  return state;\n};\nexport const getNavigableIndexes = spec => {\n  let max = spec.infinite ? spec.slideCount * 2 : spec.slideCount;\n  let breakpoint = spec.infinite ? spec.slidesToShow * -1 : 0;\n  let counter = spec.infinite ? spec.slidesToShow * -1 : 0;\n  let indexes = [];\n  while (breakpoint < max) {\n    indexes.push(breakpoint);\n    breakpoint = counter + spec.slidesToScroll;\n    counter += Math.min(spec.slidesToScroll, spec.slidesToShow);\n  }\n  return indexes;\n};\nexport const checkNavigable = (spec, index) => {\n  const navigables = getNavigableIndexes(spec);\n  let prevNavigable = 0;\n  if (index > navigables[navigables.length - 1]) {\n    index = navigables[navigables.length - 1];\n  } else {\n    for (let n in navigables) {\n      if (index < navigables[n]) {\n        index = prevNavigable;\n        break;\n      }\n      prevNavigable = navigables[n];\n    }\n  }\n  return index;\n};\nexport const getSlideCount = spec => {\n  const centerOffset = spec.centerMode\n    ? spec.slideWidth * Math.floor(spec.slidesToShow / 2)\n    : 0;\n  if (spec.swipeToSlide) {\n    let swipedSlide;\n    const slickList = ReactDOM.findDOMNode(spec.listRef);\n    const slides = slickList.querySelectorAll(\".slick-slide\");\n    Array.from(slides).every(slide => {\n      if (!spec.vertical) {\n        if (\n          slide.offsetLeft - centerOffset + getWidth(slide) / 2 >\n          spec.swipeLeft * -1\n        ) {\n          swipedSlide = slide;\n          return false;\n        }\n      } else {\n        if (slide.offsetTop + getHeight(slide) / 2 > spec.swipeLeft * -1) {\n          swipedSlide = slide;\n          return false;\n        }\n      }\n\n      return true;\n    });\n\n    if (!swipedSlide) {\n      return 0;\n    }\n    const currentIndex =\n      spec.rtl === true\n        ? spec.slideCount - spec.currentSlide\n        : spec.currentSlide;\n    const slidesTraversed =\n      Math.abs(swipedSlide.dataset.index - currentIndex) || 1;\n    return slidesTraversed;\n  } else {\n    return spec.slidesToScroll;\n  }\n};\n\nexport const checkSpecKeys = (spec, keysArray) =>\n  keysArray.reduce((value, key) => value && spec.hasOwnProperty(key), true)\n    ? null\n    : console.error(\"Keys Missing:\", spec);\n\nexport const getTrackCSS = spec => {\n  checkSpecKeys(spec, [\n    \"left\",\n    \"variableWidth\",\n    \"slideCount\",\n    \"slidesToShow\",\n    \"slideWidth\"\n  ]);\n  let trackWidth, trackHeight;\n  const trackChildren = spec.slideCount + 2 * spec.slidesToShow;\n  if (!spec.vertical) {\n    trackWidth = getTotalSlides(spec) * spec.slideWidth;\n  } else {\n    trackHeight = trackChildren * spec.slideHeight;\n  }\n  let style = {\n    opacity: 1,\n    transition: \"\",\n    WebkitTransition: \"\"\n  };\n  if (spec.useTransform) {\n    let WebkitTransform = !spec.vertical\n      ? \"translate3d(\" + spec.left + \"px, 0px, 0px)\"\n      : \"translate3d(0px, \" + spec.left + \"px, 0px)\";\n    let transform = !spec.vertical\n      ? \"translate3d(\" + spec.left + \"px, 0px, 0px)\"\n      : \"translate3d(0px, \" + spec.left + \"px, 0px)\";\n    let msTransform = !spec.vertical\n      ? \"translateX(\" + spec.left + \"px)\"\n      : \"translateY(\" + spec.left + \"px)\";\n    style = {\n      ...style,\n      WebkitTransform,\n      transform,\n      msTransform\n    };\n  } else {\n    if (spec.vertical) {\n      style[\"top\"] = spec.left;\n    } else {\n      style[\"left\"] = spec.left;\n    }\n  }\n  if (spec.fade) style = { opacity: 1 };\n  if (trackWidth) style.width = trackWidth;\n  if (trackHeight) style.height = trackHeight;\n\n  // Fallback for IE8\n  if (window && !window.addEventListener && window.attachEvent) {\n    if (!spec.vertical) {\n      style.marginLeft = spec.left + \"px\";\n    } else {\n      style.marginTop = spec.left + \"px\";\n    }\n  }\n\n  return style;\n};\nexport const getTrackAnimateCSS = spec => {\n  checkSpecKeys(spec, [\n    \"left\",\n    \"variableWidth\",\n    \"slideCount\",\n    \"slidesToShow\",\n    \"slideWidth\",\n    \"speed\",\n    \"cssEase\"\n  ]);\n  let style = getTrackCSS(spec);\n  // useCSS is true by default so it can be undefined\n  if (spec.useTransform) {\n    style.WebkitTransition =\n      \"-webkit-transform \" + spec.speed + \"ms \" + spec.cssEase;\n    style.transition = \"transform \" + spec.speed + \"ms \" + spec.cssEase;\n  } else {\n    if (spec.vertical) {\n      style.transition = \"top \" + spec.speed + \"ms \" + spec.cssEase;\n    } else {\n      style.transition = \"left \" + spec.speed + \"ms \" + spec.cssEase;\n    }\n  }\n  return style;\n};\nexport const getTrackLeft = spec => {\n  if (spec.unslick) {\n    return 0;\n  }\n\n  checkSpecKeys(spec, [\n    \"slideIndex\",\n    \"trackRef\",\n    \"infinite\",\n    \"centerMode\",\n    \"slideCount\",\n    \"slidesToShow\",\n    \"slidesToScroll\",\n    \"slideWidth\",\n    \"listWidth\",\n    \"variableWidth\",\n    \"slideHeight\"\n  ]);\n\n  const {\n    slideIndex,\n    trackRef,\n    infinite,\n    centerMode,\n    slideCount,\n    slidesToShow,\n    slidesToScroll,\n    slideWidth,\n    listWidth,\n    variableWidth,\n    slideHeight,\n    fade,\n    vertical\n  } = spec;\n\n  var slideOffset = 0;\n  var targetLeft;\n  var targetSlide;\n  var verticalOffset = 0;\n\n  if (fade || spec.slideCount === 1) {\n    return 0;\n  }\n\n  let slidesToOffset = 0;\n  if (infinite) {\n    slidesToOffset = -getPreClones(spec); // bring active slide to the beginning of visual area\n    // if next scroll doesn't have enough children, just reach till the end of original slides instead of shifting slidesToScroll children\n    if (\n      slideCount % slidesToScroll !== 0 &&\n      slideIndex + slidesToScroll > slideCount\n    ) {\n      slidesToOffset = -(slideIndex > slideCount\n        ? slidesToShow - (slideIndex - slideCount)\n        : slideCount % slidesToScroll);\n    }\n    // shift current slide to center of the frame\n    if (centerMode) {\n      slidesToOffset += parseInt(slidesToShow / 2);\n    }\n  } else {\n    if (\n      slideCount % slidesToScroll !== 0 &&\n      slideIndex + slidesToScroll > slideCount\n    ) {\n      slidesToOffset = slidesToShow - slideCount % slidesToScroll;\n    }\n    if (centerMode) {\n      slidesToOffset = parseInt(slidesToShow / 2);\n    }\n  }\n  slideOffset = slidesToOffset * slideWidth;\n  verticalOffset = slidesToOffset * slideHeight;\n\n  if (!vertical) {\n    targetLeft = slideIndex * slideWidth * -1 + slideOffset;\n  } else {\n    targetLeft = slideIndex * slideHeight * -1 + verticalOffset;\n  }\n\n  if (variableWidth === true) {\n    var targetSlideIndex;\n    let trackElem = ReactDOM.findDOMNode(trackRef);\n    targetSlideIndex = slideIndex + getPreClones(spec);\n    targetSlide = trackElem && trackElem.childNodes[targetSlideIndex];\n    targetLeft = targetSlide ? targetSlide.offsetLeft * -1 : 0;\n    if (centerMode === true) {\n      targetSlideIndex = infinite\n        ? slideIndex + getPreClones(spec)\n        : slideIndex;\n      targetSlide = trackElem && trackElem.children[targetSlideIndex];\n      targetLeft = 0;\n      for (let slide = 0; slide < targetSlideIndex; slide++) {\n        targetLeft -=\n          trackElem &&\n          trackElem.children[slide] &&\n          trackElem.children[slide].offsetWidth;\n      }\n      targetLeft -= parseInt(spec.centerPadding);\n      targetLeft += targetSlide && (listWidth - targetSlide.offsetWidth) / 2;\n    }\n  }\n\n  return targetLeft;\n};\n\nexport const getPreClones = spec => {\n  if (spec.unslick || !spec.infinite) {\n    return 0;\n  }\n  if (spec.variableWidth) {\n    return spec.slideCount;\n  }\n  return spec.slidesToShow + (spec.centerMode ? 1 : 0);\n};\n\nexport const getPostClones = spec => {\n  if (spec.unslick || !spec.infinite) {\n    return 0;\n  }\n  return spec.slideCount;\n};\n\nexport const getTotalSlides = spec =>\n  spec.slideCount === 1\n    ? 1\n    : getPreClones(spec) + spec.slideCount + getPostClones(spec);\nexport const siblingDirection = spec => {\n  if (spec.targetSlide > spec.currentSlide) {\n    if (spec.targetSlide > spec.currentSlide + slidesOnRight(spec)) {\n      return \"left\";\n    }\n    return \"right\";\n  } else {\n    if (spec.targetSlide < spec.currentSlide - slidesOnLeft(spec)) {\n      return \"right\";\n    }\n    return \"left\";\n  }\n};\n\nexport const slidesOnRight = ({\n  slidesToShow,\n  centerMode,\n  rtl,\n  centerPadding\n}) => {\n  // returns no of slides on the right of active slide\n  if (centerMode) {\n    let right = (slidesToShow - 1) / 2 + 1;\n    if (parseInt(centerPadding) > 0) right += 1;\n    if (rtl && slidesToShow % 2 === 0) right += 1;\n    return right;\n  }\n  if (rtl) {\n    return 0;\n  }\n  return slidesToShow - 1;\n};\n\nexport const slidesOnLeft = ({\n  slidesToShow,\n  centerMode,\n  rtl,\n  centerPadding\n}) => {\n  // returns no of slides on the left of active slide\n  if (centerMode) {\n    let left = (slidesToShow - 1) / 2 + 1;\n    if (parseInt(centerPadding) > 0) left += 1;\n    if (!rtl && slidesToShow % 2 === 0) left += 1;\n    return left;\n  }\n  if (rtl) {\n    return slidesToShow - 1;\n  }\n  return 0;\n};\n\nexport const canUseDOM = () =>\n  !!(\n    typeof window !== \"undefined\" &&\n    window.document &&\n    window.document.createElement\n  );\n"]},"metadata":{},"sourceType":"module"}